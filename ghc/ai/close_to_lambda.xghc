#define direction int 0
#define lam_pos int 1
#define lam2_pos int 2
#define my_id int 3
#define ghost_start_axis int 4
#define ghost_axis int 5
#define ghost_status int 6
#define floor int 7

#define LAM_POS_X [100]
#define LAM_POS_Y [101]
#define LAM2_POS_X [102]
#define LAM2_POS_Y [103]

#define POS_X [104]
#define POS_Y [105]
#define DIRECTION [106]
#define VITALITY [107]
#define DIST_X [108]
#define DIST_Y [109]
#define DIST_X_2 [110]
#define DIST_Y_2 [111]
#define FLOOR_START_MEMORY 112
#define UP [112]
#define RIGHT [113]
#define DOWN [114]
#define LEFT [115]
#define BRANCH [116]
#define TURN [117]
#define IS_RIGHT [118]
#define IS_DOWN [119]

#define RADIUS 5

;;;; TURN RESET ;;;;
; TODO

;;;; 過去の方向 ;;;;
  @my_id
  @ghost_status
  mov @VITALITY,a
  mov @DIRECTION,b
  inc [b] ; 今まで行った方向++;

;;;;; 自分の座標を知る ;;;;
  @my_id
  @ghost_axis
  mov @POS_X, a
  mov @POS_Y, b

;;;;;Count Branch;;;;;;
  mov @BRANCH, 0
  mov g, 0 ;; i
  mov f, @FLOOR_START_MEMORY

  ;; FOR
  :start_up3
  jgt @end_up3, g, 3
    ;;初期化
    mov a,@POS_X
    mov b,@POS_Y

    ;;SWICH 方向
    jeq @s0, g, 0 
    jeq @s1, g, 1
    jeq @s2, g, 2
    jeq @s3, g, 3

    :s0
      dec b
      jeq @end_up3swich, 0, 0
    :s1
      inc a
      jeq @end_up3swich, 0, 0
    :s2
      inc b
      jeq @end_up3swich, 0, 0
    :s3
      dec a
      jeq @end_up3swich, 0, 0
    :end_up3swich

    @floor ;; a = a, bの床情報を
    mov [f], a ;;床情報を入れる

    ;; その方向にすすめるか
    jlt @end_count_branch, a, 1
      inc @BRANCH
    :end_count_branch
    
    inc g
    inc f
  jlt @start_up3, g, 4
  :end_up3


  ;;debug  g,f : used
  ; mov a, 77
  ; mov b, @UP
  ; mov c, @RIGHT
  ; mov d, @DOWN
  ; mov e, @LEFT
  ; mov h, @BRANCH
  ; int 8


;;;BRANCHじゃなければ終了;;;;;;
  jlt @fin, @BRANCH, 3

;;;;;;; 敵の座標を知る ;;;;;;;;
  @lam_pos
  mov @LAM_POS_X, a
  mov @LAM_POS_Y, b

;;;;;; 敵の位置 1:True ;;;;;;;
  ;; 右に敵がいるか;;

    ; if LAM_POS_X <= posX
    jgt @gt_lambda_x, @LAM_POS_X, @POS_X
      ; if LAM_POS_X < posX
      jeq @eq_lambda_x, @LAM_POS_X, @POS_X
        mov @IS_RIGHT, 0
        jeq @end_gt_lambda_x, 0, 0
      ; elif LAM_POS_X == posX
      :eq_lambda_x 
        mov @IS_RIGHT, 1
        jeq @end_gt_lambda_x, 0, 0
    ; elif LAM_POS_X > POS_X
    :gt_lambda_x
      mov @IS_RIGHT, 2
    :end_gt_lambda_x

  ;; 下に敵がいるか;;
    jgt @gt_lambda_y, @LAM_POS_Y, @POS_Y
      jeq @eq_lambda_y, @LAM_POS_Y, @POS_Y
        mov @IS_DOWN, 0
        jeq @end_gt_lambda_y, 0, 0
      :eq_lambda_y
        mov @IS_DOWN, 1
        jeq @end_gt_lambda_y, 0, 0
    :gt_lambda_y
      mov @IS_DOWN, 2
    :end_gt_lambda_y

  ;; debug
  mov a, 111
  mov b, @IS_RIGHT
  mov c, @IS_DOWN
  mov d, 0
  int 8



;;;;;;;;;行ける方向;;;;;;;;;;;;
mov c, 0;; max
mov d, 0;; max direction

mov f, @FLOOR_START_MEMORY ;floor
mov g, 0;; i

:start_calc_priority
jgt @end_calc_priority, g, 3
  jeq @pass_calc_priority, @DIRECTION, g ; 同じ方向以外なら
    mov a, [f]

    ; 5以上なら、空判定
    jlt @non_start_pos, a, 5
      mov a, 1
    :non_start_pos

    ;; if maximum < floor_value:
    jgt @pass_up, c, a   

      ;; if maxi < floor value
      jeq @eq_priority, c, a
        mov c, a
        mov d, g
        jeq @pass_up, 0, 0

      ;; elif maxi == floor value
      :eq_priority




    :pass_up
  :pass_calc_priority
  inc g
  inc f
jlt @start_calc_priority, g, 4
:end_calc_priority

mov a, d
@direction

jeq @fin, 0, 0 ;終了
:fin

hlt