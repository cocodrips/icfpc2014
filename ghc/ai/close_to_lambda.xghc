#define direction int 0
#define lam_pos int 1
#define lam2_pos int 2
#define my_id int 3
#define ghost_start_axis int 4
#define ghost_axis int 5
#define ghost_status int 6
#define floor int 7

#define LAM_POS_X [100]
#define LAM_POS_Y [101]
#define LAM2_POS_X [102]
#define LAM2_POS_Y [103]

#define POS_X [104]
#define POS_Y [105]
#define DIRECTION [106]
#define VITALITY [107]
#define DIST_X [108]
#define DIST_Y [109]
#define DIST_X_2 [110]
#define DIST_Y_2 [111]
#define FLOOR_START_MEMORY 112
#define UP [112]
#define RIGHT [113]
#define DOWN [114]
#define LEFT [115]
#define BRANCH [116]
#define TURN [117]
#define IS_RIGHT [118]
#define IS_DOWN [119]

#define RADIUS 5

;;;; TURN RESET ;;;;
; TODO

;;;; 過去の方向 ;;;;
  @my_id
  @ghost_status
  mov @VITALITY,a
  mov @DIRECTION,b
  inc [b] ; 今まで行った方向++;

;;;;; 自分の座標を知る ;;;;
  @my_id
  @ghost_axis
  mov @POS_X, a
  mov @POS_Y, b

;;;;;Count Branch;;;;;;
  mov @BRANCH, 0
  mov g, 0 ;; i
  mov f, @FLOOR_START_MEMORY

  ;; FOR
  :start_up3
  jgt @end_up3, g, 3
    ;;初期化
      mov a,@POS_X
      mov b,@POS_Y

    ;;SWICH 方向
      jeq @s0, g, 0 
      jeq @s1, g, 1
      jeq @s2, g, 2
      jeq @s3, g, 3

      :s0
        dec b
        jeq @end_up3swich, 0, 0
      :s1
        inc a
        jeq @end_up3swich, 0, 0
      :s2
        inc b
        jeq @end_up3swich, 0, 0
      :s3
        dec a
        jeq @end_up3swich, 0, 0
      :end_up3swich
  
    ;; START regist floor
      ;; if 敵のポジション
        jeq @not_lamda_pos_2, a, @LAM_POS_X
          jeq @not_lamda_pos_2, b, @LAM_POS_Y
              mov [f], 5
            jeq @regist_floor, 0, 0
        :not_lamda_pos_2
      ;; そうじゃなければ
        @floor ;; a = a, bの床情報を
        mov [f], a ;;床情報を入れる
        jlt @regist_floor, a, 5 ; 5以上なら、空判定
          mov a, 1

      :regist_floor


    ;; その方向にすすめるか
    jlt @end_count_branch, a, 1
      inc @BRANCH
    :end_count_branch
    
    inc g
    inc f
  jlt @start_up3, g, 4
  :end_up3


  ;;debug  g,f : used
  ; mov a, 77
  ; mov b, @UP
  ; mov c, @RIGHT
  ; mov d, @DOWN
  ; mov e, @LEFT
  ; mov h, @BRANCH
  ; int 8


;;;BRANCHじゃなければ終了;;;;;;
  jlt @fin, @BRANCH, 3

;;;;;;; 敵の座標を知る ;;;;;;;;
  @lam_pos
  mov @LAM_POS_X, a
  mov @LAM_POS_Y, b

;;;;;; 敵の位置 1:True ;;;;;;;
  ;; 右に敵がいるか;;

    ; if LAM_POS_X <= posX
    jgt @gt_lambda_x, @LAM_POS_X, @POS_X
      ; if LAM_POS_X < posX
      jeq @eq_lambda_x, @LAM_POS_X, @POS_X
        mov @IS_RIGHT, 0
        jeq @end_gt_lambda_x, 0, 0
      ; elif LAM_POS_X == posX
      :eq_lambda_x 
        mov @IS_RIGHT, 1
        jeq @end_gt_lambda_x, 0, 0
    ; elif LAM_POS_X > POS_X
    :gt_lambda_x
      mov @IS_RIGHT, 2
    :end_gt_lambda_x

  ;; 下に敵がいるか;;
    jgt @gt_lambda_y, @LAM_POS_Y, @POS_Y
      jeq @eq_lambda_y, @LAM_POS_Y, @POS_Y
        mov @IS_DOWN, 0
        jeq @end_gt_lambda_y, 0, 0
      :eq_lambda_y
        mov @IS_DOWN, 1
        jeq @end_gt_lambda_y, 0, 0
    :gt_lambda_y
      mov @IS_DOWN, 2
    :end_gt_lambda_y

  ;; debug
  ; mov a, 111
  ; mov b, @IS_RIGHT
  ; mov c, @IS_DOWN
  ; mov d, 0
  ; int 8



;;;;;;;;;行ける方向;;;;;;;;;;;;
mov c, 0;; max
mov d, 0;; max direction

mov e, 0 ;;方向の優先度
mov f, @FLOOR_START_MEMORY ;floor
mov g, 0;; i


:start_calc_priority
jgt @end_calc_priority, g, 3
  mov a, 2
  xor a, @DIRECTION
  jeq @pass_calc_priority, a, g ; 戻らないなら
    mov a, [f]
    ;; if maximum <= floor_value:
    jgt @pass_up, c, a   

      ;;SWICH 方向の優先度
      mov b, 2
      jeq @p0, g, 0
      jeq @p1, g, 1
      jeq @p2, g, 2
      jeq @p3, g, 3

      :p0 ;;上
        sub b, @IS_DOWN
        jeq @end_p_swich, 0, 0
      :p1 ;; 右
        mov b, @IS_RIGHT 
        jeq @end_p_swich, 0, 0
      :p2 ;; 下
        mov b, @IS_DOWN
        jeq @end_p_swich, 0, 0
      :p3 ;; 左
        sub b, @IS_RIGHT
        jeq @end_p_swich, 0, 0
      :end_p_swich

      ;; if maxi < floor value
      ;; TODO:下のブロックと最適化
      jeq @eq_priority, c, a
        mov c, a
        mov d, g
        mov e, b
        
        mov h, 88
        int 8 
        
        jeq @pass_up, 0, 0

      ;; elif maxi == floor value
      :eq_priority
        jlt @pass_up, b, e
          mov d, g
          mov e, b

          mov h, 44
          int 8 

    :pass_up
  :pass_calc_priority
  inc g
  inc f
jlt @start_calc_priority, g, 4
:end_calc_priority

mov a, d
@direction

jeq @fin, 0, 0 ;終了
:fin

hlt